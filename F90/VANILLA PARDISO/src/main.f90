PROGRAM ELLSOLVE_F90
	! C BINDINGS MODULE USED FOR PROPER C SIZES.
	USE ISO_C_BINDING
	! SYSTEM MODULES.
	USE IFPORT
	USE IFCORE
	! NO IMPLICIT VARIABLES.
	IMPLICIT NONE 
	! PARAMETERS.
	INTEGER(KIND=C_INT) :: NRINTERIOR = 256
	INTEGER(KIND=C_INT) :: NZINTERIOR = 64
	REAL(KIND=C_DOUBLE) :: DR = 0.03125
	REAL(KIND=C_DOUBLE) :: DZ = 0.125
	INTEGER(KIND=C_INT) :: NORDER = 2
	CHARACTER(LEN=256) :: DIRNAME = 'output'
	! GRID VARIABLES.
	INTEGER(KIND=C_INT) :: GHOST, NRTOTAL, NZTOTAL, ARRAY_DIM
	! GRID FUNCTIONS.
	REAL(KIND=C_DOUBLE), DIMENSION(:), ALLOCATABLE :: R, Z, U, F, S, RES
	! AUXILIARY VARIABLES.
	REAL(KIND=C_DOUBLE) :: AUX_R, AUX_Z
	INTEGER(KIND=C_INT) :: I, J, K
	! SOLUTION PARAMETERS.
	INTEGER(KIND=C_INT) :: ROBIN = 1
	REAL(KIND=C_DOUBLE) :: UINF = 1.0
	INTEGER(KIND=C_INT) :: RSYM = 1, ZSYM = 1
	INTEGER(KIND=C_INT) :: PRECOND_USE = 0
	! VARIOUS TIMERS.
	REAL(KIND=C_DOUBLE) :: START_TIME(10), END_TIME(10), TIMES(10)
	! NUMBER OF ARGUMENTS.
	INTEGER(KIND=C_INT) :: NUM_ARG
	! ARGUMENTS.
	CHARACTER(LEN=256) :: ARGS(8), STRING
	! SYSTEM COMMAND STATUS.
	INTEGER(KIND=C_INT) :: ERRNUM
	LOGICAL(KIND=4) :: L_RESULT
	! USER INPUT CHARACTER.
	CHARACTER(KIND=C_CHAR) :: OPT

	! PROCESS PARAMETERS.
	! GET ARGUMENTS FROM COMMAND LINE.
	NUM_ARG = NARGS()

	! SANITY CHECK.
	IF (NUM_ARG .NE. 7) THEN
		PRINT *, 'ELLSOLVEF: WARNING! Usage is $./ELLSOLVEF dirname norder NrInterior NzInterior dr dz'
		PRINT *, '           [dirname] is a valid directory string name.'
		PRINT *, '           [norder] = is and integer equal to 2 or 4 corresponding to the finite difference order.'
		PRINT *, '           [NrInterior] and [NzInterior] are itegers equal to the number of interior points in r, z.'
		PRINT *, '           [dr] and [dz] are floating point dobles equal to the spatial step in r, z.'
		PRINT *, 'Press (y/n) to procede with default arguments:'
		OPT = GETCHARQQ()
		IF ((OPT == 'Y').OR.(OPT == 'y')) THEN
			PRINT *, 'ELLSOLVEF: User chose to proceed with default arguments.'
		ELSE
			PRINT *, 'ELLSOLVEF: User chose to abort.'
			CALL EXIT(1)
		END IF
	ELSE
		! GET ARGUMENTS DOING SOME SANITY CHECKS.
		! DIRECTORY NAME.
		CALL GETARG(1, DIRNAME)

		! FINITE DIFFERENCE ORDER.
		CALL GETARG(2, STRING)
		READ (STRING, *) NORDER

		! NUMBER OF INTERIOR POINTS.
		CALL GETARG(3, STRING)
		READ (STRING, *) NRINTERIOR
		CALL GETARG(4, STRING)
		READ (STRING, *) NZINTERIOR

		! SPATIAL STEPS.
		CALL GETARG(5, STRING)
		READ (STRING, *) DR
		CALL GETARG(6, STRING)
		READ (STRING, *) DZ
	END IF

	! DO I/O ON OUTPUT DIRECTORY.
	! CREATE DIRECTORY.
	L_RESULT = MAKEDIRQQ(DIRNAME)
	! CHECK FOR FAILURE.
	IF (.NOT.L_RESULT) THEN
		ERRNUM = GETLASTERRORQQ()
		! PERMISSION DENIED.
		IF (ERRNUM == ERR$ACCES) THEN
			PRINT *, 'ERROR: Permision denied on MKDIR ', DIRNAME
			CALL EXIT(1)
		ELSE IF (ERRNUM == ERR$EXIST) THEN
			PRINT *, 'ELLSOLVEF: WARNING! Directory ', DIRNAME, ' already existes.'
			PRINT *, 'Press (y/n) to procede and possibly overwrite files:'
			OPT = GETCHARQQ()
			IF ((OPT == 'Y').OR.(OPT == 'y')) THEN
				PRINT *, 'ELLSOLVEF: User chose to proceed.'
			ELSE
				PRINT *, 'ELLSOLVEF: User chose to abort.'
				CALL EXIT(1)
			END IF
		ELSE IF (ERRNUM == ERR$NOENT) THEN
			PRINT *, 'ERROR: Path specified was not found on MKDIR ', DIRNAME
			CALL EXIT(1)
		END IF
	ENDIF

	! CD TO DIRECTORY.
	L_RESULT = CHANGEDIRQQ(DIRNAME)
	! CHECK FOR FAILURE.
	IF (.NOT.L_RESULT) THEN
		PRINT *, 'ELLSOLVEF: WARNIN! Could no CD to directory ', DIRNAME
		PRINT *, 'Press (y/n) to procede and write in current directory:'
		OPT = GETCHARQQ()
		IF ((OPT == 'Y').OR.(OPT == 'y')) THEN
			PRINT *, 'ELLSOLVEF: User chose to proceed.'
		ELSE
			PRINT *, 'ELLSOLVEF: User chose to abort.'
			CALL EXIT(1)
		END IF
	ENDIF

	! GET NUMBER OF GHOST ZONES ACCORDING TO FINITE DIFFERENCE ORDER.
	IF (NORDER == 2) THEN
		GHOST = 2
	ELSEIF (NORDER == 4) THEN
		GHOST = 3
	END IF
	! CALCULATE LONGITUDINAL DIMENSIONS.
	NRTOTAL = GHOST + NRINTERIOR + 1
	NZTOTAL = GHOST + NZINTERIOR + 1
	! TOTAL GRID SIZE.
	ARRAY_DIM = NRTOTAL * NZTOTAL

	! PRINT INFO TO SCREEN.
	PRINT *, 'ELLSOLVEF: System parameters are:'
	PRINT *, '		NrInt	= ', NRINTERIOR
	PRINT *, '		NzInt	= ', NZINTERIOR
	PRINT *, '		ghost	= ', GHOST
	PRINT *, '		dr	= ', DR
	PRINT *, '		dz	= ', DZ
	PRINT *, '		order	= ', NORDER

	! ALLOCATE GRID FUNCTIONS, INDEX LIKE FORTRAN.
	PRINT *, 'ELLSOLVEF: Allocating memory...'
	ALLOCATE(R(1:ARRAY_DIM), Z(1:ARRAY_DIM), U(1:ARRAY_DIM),&
		 F(1:ARRAY_DIM), S(1:ARRAY_DIM), RES(1:ARRAY_DIM))
	PRINT *, 'ELLSOLVEF: Allocated memory.'

	! FILL GRID FUNCTIONS AND LINEAR SOURCE.
	!$OMP PARALLEL SHARED(R, Z, U, F, S, RES) PRIVATE(AUX_R, AUX_Z, J, K)
	!$OMP DO SCHEDULE(GUIDED)
	DO I = 1, NRTOTAL
		AUX_R = (DBLE(I - GHOST) - 0.5) * DR
		DO J = 1, NZTOTAL
			AUX_Z = (DBLE(J - GHOST) - 0.5) * DZ
			! LINEAR INDEX.
			K = (I - 1) * NZTOTAL + J
			R(K) = AUX_R
			Z(K) = AUX_Z
			U(K) = 1.0
			F(K) = 0.0
			RES(K) = 0.0
			S(K) = EXP(-AUX_R**2-AUX_Z**2) * (0.5 + AUX_R**2 * (-3.0 + AUX_R**2 + AUX_Z**2))
		END DO
	END DO
	!$OMP END DO
	!$OMP END PARALLEL
	PRINT *, 'ELLSOLVEF: Filled grid functions.'

	! CALL C TO PRINT ARRAYS: NOTICE HOW VARIABLES ARE PASSED BY VALUE.
	CALL WRITE_SINGLE_FILE(R, 'r.asc'//C_NULL_CHAR, %VAL(NRTOTAL), %VAL(NZTOTAL))
	CALL WRITE_SINGLE_FILE(Z, 'z.asc'//C_NULL_CHAR, %VAL(NRTOTAL), %VAL(NZTOTAL))
	CALL WRITE_SINGLE_FILE(S, 's.asc'//C_NULL_CHAR, %VAL(NRTOTAL), %VAL(NZTOTAL))
	CALL WRITE_SINGLE_FILE(F, 'f.asc'//C_NULL_CHAR, %VAL(NRTOTAL), %VAL(NZTOTAL))
	PRINT *, 'ELLSOLVEF: Printed grid functions.'

	! INTIALIZE MEMORY AND PARAMETERS.
	CALL PARDISO_START(%VAL(NRINTERIOR), %VAL(NZINTERIOR))

	! CALL VANILLA SOLVER.
	! ONCE AGAIN, NOTICE THAT VARIABLES ARE PASSED BY VALUE.
	PRINT *, 'ELLSOLVEF: Calling normal solver.'
	CALL CPU_TIME(START_TIME(1))
	CALL FLAT_LAPLACIAN(U, F, RES, S, %VAL(UINF), %VAL(ROBIN), %VAL(RSYM), %VAL(ZSYM),&
		%VAL(NRINTERIOR), %VAL(NZINTERIOR), %VAL(GHOST),&
		%VAL(DR), %VAL(DZ), %VAL(NORDER),&
		%VAL(PRECOND_USE))
	CALL CPU_TIME(END_TIME(1))
	TIMES(1) = END_TIME(1) - START_TIME(1)

	PRINT *, 'ELLSOLVEF: Solving with CGS.'
	PRECOND_USE = 6
	CALL CPU_TIME(START_TIME(2))
	CALL FLAT_LAPLACIAN(U, F, RES, S, %VAL(UINF), %VAL(ROBIN), %VAL(RSYM), %VAL(ZSYM),&
		%VAL(NRINTERIOR), %VAL(NZINTERIOR), %VAL(GHOST),&
		%VAL(DR), %VAL(DZ), %VAL(NORDER),&
		%VAL(PRECOND_USE))
	CALL CPU_TIME(END_TIME(2))
	TIMES(2) = END_TIME(2) - START_TIME(2)

	! PRINT EXECUTION TIMES.
	PRINT *, 'ELLSOLVEF: Normal solver took ', TIMES(1), ' seconds.'
	PRINT *, 'ELLSOLVEF: Solver with CGS took ', TIMES(2), ' seconds.'
	
	! WRITE SOLUTION AND RESIDUAL.
	CALL WRITE_SINGLE_FILE(U, 'u.asc'//C_NULL_CHAR, %VAL(NRTOTAL), %VAL(NZTOTAL))
	CALL WRITE_SINGLE_FILE(RES, 'res.asc'//C_NULL_CHAR, %VAL(NRTOTAL), %VAL(NZTOTAL))

	! CLEAR MEMORY AND PARAMETERS FOR PARDISO.
	CALL PARDISO_STOP()

	! DEALLOCATE MEMORY.
	PRINT *, 'ELLSOLVEF: Deallocating memory...'
	DEALLOCATE(R, Z, U, F, S, RES)
	PRINT *, 'ELLSOLVEF: Deallocated memory.'
	! ALL DONE.
END PROGRAM ELLSOLVE_F90
